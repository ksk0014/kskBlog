<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式系统部署工具]]></title>
    <url>%2FkskBlog%2F2018%2F05%2F05%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[背景分布式集群搭建通常具体以下几个难点: 具有复杂的机器拓扑结构 配置管理错综复杂 模块之间的启动顺序有着强依赖 模块版本变更由于跨机器十分不便 集群外部系统依赖复杂且难以管理 对于一套可以简洁易用的中控式搭建、初始化、变更、监控集群的部署工具有强需求，可以提高小型开发团队在系统迭代阶段的效率 功能 根据集群拓扑结构的规划自动搭建整套集群 提供自定义配置、变更配置功能 自动处理好外部系统依赖的初始化工作，如mysql系统的建库建表 自动完成本系统的环境初始化工作 自动生成全集群各模块的启停及状态监控脚本 代码结构代码路径: https://github.com/ksk0014/distributed-systems-deploy 下载下来后会有三个目录: conf目录: 模块配置文件, machine.xxx代表集群拓扑结构规划 bin目录: 集群部署、升级脚本 auto-deploy-cluster: 主运行程序，模板目录 conf说明 文件 说明 cluster.conf 搭建的所有配置,在文件中有详细注释 diy.conf 模块自定义配置，端口类的配置可以忽略，此类配置系统会自动分配得出 machine.xxx 某个模板需要搭建的机器, 每一行表示一个机器 数据结构模板数据组织结构如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788group = &#123; &quot;instances&quot;: [ &amp;instance1, &amp;instance2 ]&#125;region = &#123;&#125;#同group #搭建的某个实例instance = &#123;&quot;name&quot;: str, #唯一标识某个搭建模块的名字&quot;dir_name&quot;: str, #在机器上的部署目录,同一模块在同一机器上部署多个时该值不一样&quot;app_type&quot;: str, #见application中的name&quot;on_machine&quot;: str, #机器名,与machine中的name对应&quot;group&quot;: int, #暂时未用&quot;region&quot;: int, #fileserver 的region标识&quot;idx&quot;: int, #该模块的第几个实例,&quot;idx_in_group&quot;: int, #在group中该实例的index&quot;machine_ref&quot;: &amp;&#123;machine&#125;, #见machine数据结构&quot;application_ref&quot;: &amp;&#123;application&#125;, #见application数据结构&quot;group_ref&quot;: &amp;&#123;group&#125;, #见group数据结构&quot;region_ref&quot;: &amp;&#123;region&#125;, #见region数据结构&quot;idx_in_region&quot;: int, #region中该实例的index&quot;ports&quot;: &#123; &quot;port_name&quot;: int, #port_name来源于application中的port_name,根据不同的模块而不一样 ...&#125;,&quot;region_name&quot;: str&#125;#固定数据结构,数据中每个元素表示某一个模块,即一个applicationapplications = [&#123; #一个application &quot;name&quot;: &quot;xxx|yyy|zzz&quot;, &quot;dir_tmpl&quot;: str, #模板目录,一般不会用到, &quot;port_names&quot;: [&quot;xx_port&quot;, &quot;xx_port&quot;], #不同的模块的port_name不一样,可查看代码 &quot;idx&quot;: int, #一般不会用到 &quot;instances&quot;: [&amp;instance], #模块的instance列表 &quot;group_with_name&quot;: &#123; &quot;group_name&quot;: &amp;group, #group_name是一个int值 ... &#125;, &quot;region_with_name&quot;:&#123; &quot;region_name&quot;: &amp;region, #同上 &#125;, &quot;groups&quot;: [&amp;group], #group的列表, &quot;region&quot;: [&amp;region], #region的列表&#125;,&#123;...&#125;] #搭建的机器信息machines = [&#123; &quot;name&quot;: str, #机器标识,不一定是机器名,与instance中的on_machine对应 &quot;deploy__address&quot;: str, #格式为user_name@machine_host这种格式 &quot;deploy__dest_dir&quot;: str, #在机器上的搭建目录 &quot;ip&quot;: str, #机器ip &quot;user_name&quot;: str, #机器用户名 &quot;pass&quot;: str, #机器密码 &quot;idx&quot;: int, #机器的index &quot;instances&quot;: [&amp;instance], #机器上搭建的instance列表&#125;] #几个全局变量machine_with_name = &#123; &quot;name&quot;: &amp;machine, &quot;name2&quot;: &amp;machine, ...&#125; application_with_name = &#123; &quot;name&quot;: &amp;application, ...&#125; group_with_name = &#123; &quot;name&quot;: &amp;group&#125; region_with_name = &#123; &quot;name&quot;: &amp;region&#125; 使用部署集群: 设计拓扑结构 完成模块配置设定 bin目录下执行 install.sh, 等待集群安装完毕 更新集群: 修改集群配置，及模块配置 bin目录下执行 upgrade.sh module_name, 等待更新完毕 集群中控: 部署完毕生成shell目录，支持模块级别的启停、存活状态、机器资源耗费的检查]]></content>
      <categories>
        <category>部署工具</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式存储质量保障体系]]></title>
    <url>%2FkskBlog%2F2018%2F05%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[测试流程代码review –&gt; UT（L1）–&gt; L2（简单功能测试）–&gt; L3（全量回归测试）–&gt; 异常环境 –&gt; 集成测试 –&gt; 性能测试 –&gt; 自动上线 –&gt; 线上灰度测试 测试流程功能简述代码review：主要是代码规范性检查，coding风格、代码书写合理性（项目高工查），测试人员需要关注log打印是否合理、是否有冗余或缺失、日志级别是否合理 UT：auto trigger，UT测试代码由研发人员负责编写，测试人员需要维护UT测试环境、推动单测问题解决、推动单测覆盖率提升 L2：auto trigger，测试用例为全量测试中的一小部分，测试时长在30分钟以内，目的是快速发现CI代码在基本接口功能上面存在的问题，及时推动研发人员解决 L3：daily build，全量测试，考察代码在复杂场景下、单个异常下运行情况，测试时间应当在12h以内，测试问题第二天及时反馈RD解决，问题绝不过夜 failover：hand trigger，全量回归三轮无异常，版本拉分支进入异常环境，多种异常混合、持续压力、异常预案演练、集群服务能力评估，运行三天无问题，产出测试报告 集成测试：hand trigger upgrade，failover环境三天无问题，版本进入集成环境，版本兼容性测试、上下游模块对接测试，观察三天 性能测试：hand trigger，集成环境三天无异常，开始集群性能测试，观察版本间性能是否存在回退，如存在推动定位调优，产出性能测试报告 自动上线：hand trigger，借助变更平台上线 线上灰度测试：版本上线时触发，代码相对简单，测试需要关注的是平台维护、报警信息补全完善 新patch测试须知 功能设计阶段：参与设计讨论 功能开发阶段：与研发功能确认接口，开发对应测试用例，编写测试方案设计文档 功能提测阶段：review功能实现逻辑，最好能看懂业务逻辑层面的代码，调通新增测试用例，加入回归测试 功能验收阶段：稳定回归3轮，有问题及时推动解决，问题绝不过夜，及时更新测试进度记录文档 分支测试阶段：功能验收通过，推入failover环境，有问题及时推动解决，产出测试报告 集成环境观察阶段：上线集成环境，观察兼容性、联调上下游环境、性能回退，产出测试报告 最后上线阶段：冒烟测试]]></content>
      <categories>
        <category>测试设计</category>
      </categories>
      <tags>
        <tag>Testing Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块存储性能测试]]></title>
    <url>%2FkskBlog%2F2018%2F05%2F04%2F%E5%9D%97%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[业务需求块存储服务推出后，需要针对各种产品宣称性能做基准性能评估。存储领域中性能评估指标主要分为三类IOPS、throughput、latency 目前业界对于块存储的产品划分情况如下: 产品类型 性能特点 应用场景 主流厂商支持情况 near local &gt;= 本地ssd盘性能 大型OLTP数据库/NoSQL数据库/ELK分布式日志 阿里云ESSD SSD云盘 20000IOPS左右 I/O密集型应用/中型关系数据库/NoSQL数据库 主流厂商均支持 高效云盘 性能够用就好，5000IOPS左右 开发与测试业务/小型负载数据库/系统盘 主流厂商均支持 普通云盘 sata介质，吞吐优化型500MBps，冷存储250MBps以下 大数据/数据仓库/日志处理 aws划分更细致，阿里云已淘汰 分层测试框架分布式块存储性能测试考量需要覆盖以下的层次: 系统网络性能、物理磁盘性能测试 存储核心系统读写性能测试，stress_tool、data_consistency_tool 宿主机上云盘性能、以及虚拟机上的云盘性能，PTS测试模型，fio 设备上文件系统性能测试，filebench，iozone等等 实际应用负载测试，sysbench OLTP、分布式数据分析框架IO负载仿真 用户常用操作的易用性 块存储性能测试需要从两个视角看： 用户维度：针对系统中单一卷实例可以获得稳定且可预期的性能，更多关注上述3 ~ 6的测试层次，本文主要讲解第3个层次的测试设计 集群维度：针对集群可服务能力的性能评估，保障系统整体稳定可控，更多关注上述1 ~ 2的测试层次 PTS测试模型PTS： Solid State Storage Performance Test SpecificationSNIA固态存储性能测试标准，相关文档参见 SSS_PTS_2.0.1.pdf 本文测试设计主要参考上述文档，并针对云环境做了相应适配 测试步骤根据 PTS 规范，SSD 性能测试需要经过以下四个步骤： 净化（purge）：通过擦除数据，将 SSD 置于接近 FOB 状态。 事先准备工作负载（WIPC）：写入规定的数据到整个 SSD，帮助其达到稳态。 正式测试之前的准备工作（WDPC）：循环运行测试，直到 SSD 进入稳态。 测试：当 SSD 进入稳态时开始测试。 备注: FOB: Fresh of Box，新鲜出盒，即硬盘刚买来的状态稳态: 性能波动范围小于预先设定的阈值 测试项IOPS测试测试在不同block size与不同的read/write 比的混合下随机IO的性能block size：100/0, 95/5, 65/35, 50/50, 35/65, 5/95, 0/100read/write：1024KiB, 128KiB, 64KiB, 32KiB, 16KiB, 8KiB, 4KiB, 0.5KiB磁盘IO的范围：100% volume size （1）purge（2）WIPC：128k顺序写2倍的磁盘空间（3）WDPC：上述工作负载（bs，r/w） loop运行（4）稳态判定：取相邻4轮的4kb 随机 0/100的iops，相对均值上下浮动在10%以内，即达到稳态，即取这四轮的测试数据为稳态窗口 测试数据，取稳态窗口的均值 Throughput测试测试在稳态的128k与1m的顺序读与顺序写的吞吐磁盘IO的范围：100% volume size （1）purge（2）WIPC：128k顺序写或1M的顺序写2倍的磁盘空间（3）WDPC：bs(128k,1M)和rw(100/0, 0/100) 顺序IO，loop，记录吞吐量（4）稳态判定：取相邻4轮的吞吐，相对均值上下浮动在10%以内，即达到稳态，即取这四轮的测试数据为稳态窗口 测试数据，取稳态窗口的均值 延迟测试测试在3种block sizes（0.5k，4k和8k），与三种读/写 比（100/0，65/35，0/100）混合下IO响应时间磁盘IO的范围：100% volume size （1）purge（2）WIPC：128k顺序写2倍的磁盘空间（3）WDPC：bs(0.5k, 4k, 8k)和rw(100/0, 65/35, 0/100) 随机IO，loop，记录最大延迟与平均延迟（4）稳态判定：取相邻4轮的平均延迟（0/100，4k），相对均值上下浮动在10%以内，即达到稳态，即取这四轮的测试数据为稳态窗口 测试数据，取稳态窗口的均值 稳定性测试测试SSD性能是随着时间以及写入量的增加是如何变化的（1min的检测穿插着30分钟的WAST测试） （1）purge（2）4k的随机写（100%），持续写入达到4倍的磁盘大小或者达到24h或者达到5轮的稳态（满足其一即可）（3）iostat统计磁盘读写性能数据，取fio延迟波动方差的数据 测试工具代码路径: https://github.com/ksk0014/block-storage-benchamrk 效果展示测试结果保存在文件中，格式如下图:]]></content>
      <categories>
        <category>测试设计</category>
      </categories>
      <tags>
        <tag>Testing Phase</tag>
      </tags>
  </entry>
</search>
